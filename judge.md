# 判断题

1. Python是一种跨平台、开源、免费的高级动态编程语言。[T]
2. Python 3.x完全兼容Python 2.x。[F]
3. 在Windows平台上编写的Python程序无法在Unix平台运行。[F]
4. 可以使用py2exe或pyinstaller等扩展库把Python源程序打包成为exe文件，从而脱离Python环境在Windows平台上运行。[T]
5. Python 3.x和Python 2.x唯一的区别就是：print在Python 2.x中是输出语句，而在Python 3.x中是输出函数。[T]
6. 不可以在同一台计算机上安装多个Python版本。[T]
7. 在IDLE交互模式下，一个下划线`“_”`表示解释器中最后一次显示的内容或最后一次语句正确执行的输出结果。[T]
8. Python程序只能在安装了Python环境的计算机上以源代码形式运行。[F]
9. 不同版本的Python不能安装到同一台计算机上。[F]
10. Python使用缩进来体现代码之间的逻辑关系。[T]
11. 为了让代码更加紧凑，编写Python程序时应尽量避免加入空格和空行。[T]
12. 在一个软件的设计与开发中，所有类名、函数名、变量名都应该遵循统一的风格和规范。[T]
13. Python代码的注释只有一种方式，那就是使用#符号。[T]
14. 放在一对三引号之间的任何内容将被认为是注释。[T]
15. Python变量使用前必须先声明，并且一旦声明就不能再当前作用域内改变其类型。[F]
16. Python采用的是基于值的自动内存管理方式。[T]
17. 在任何时刻相同的值在内存中都只保留一份。[T]
18. Python不允许使用关键字作为变量名，允许使用内置函数名作为变量名，但这会改变函数名的含义。[ ]
19. 在Python中可以使用if作为变量名。[F]
20. 在Python 3.x中可以使用中文作为变量名。[F]
21. Python变量名必须以字母或下划线开头，并且区分字母大小写。[ ]
22. 0o12f是合法的八进制数字。[F]
23. 在Python中0xad是合法的十六进制数字表示形式。[ ]
24. 3+4j是合法Python数字类型。[F]
25. 在Python中0oa1是合法的八进制数字表示形式。[ ]
26. 已知 x = 3，那么执行语句 x+=6 之后，x的内存地址不变。[ ]
27. 在Python中可以使用 for 作为变量名。[F]
28. 在Python中可以使用 id 作为变量名，尽管不建议这样做。[T]
29. Python关键字不可以作为变量名。[T]
30. Python变量名区分大小写，所以student和Student不是同一个变量。[Ts]
31. 已知x = 3，那么执行x += 6语句前后x的内存地址是不变的。[ ]
32. 在Python中，变量不直接存储值，而是存储值的引用，也就是值在内存中的地址。[ ]
33. 9999**9999这样的命令在Python中无法运行。[F]
34. 运算符 / 在Python 2.x和Python 3.x中具有相同的功能。[T]
35. 3+4j不是合法的Python表达式。[F]
36. 表达式 {1, 3, 2} > {1, 2, 3} 的值为True。[F]
37. 表达式 'a'+1的值为'b'。[F]
38. 一个数字5也是合法的Python表达式。[ ]
39. 当作为条件表达式时，[]与None等价。[ ]
40. 表达式 [] == None 的值为True。[F]
41. 当作为条件表达式时，{}与None等价。[ ]
42. 表达式 {}==None 的值为True。[F]
43. 表达式 pow(3,2) == 3**2 的值为True。[T]
44. 当作为条件表达式时，空值、空字符串、空列表、空元组、空字典、空集合、空迭代对象以及任意形 式的数字0都等价于False。[ ]
45. 表达式int('1'*64, 2)与sum(2**i for i in range(64))的计算结果是一样的，但是前者更快一些。 [ ]
46. 在条件表达式中不允许使用赋值运算符“=”，会提示语法错误。[ ]
47. 已知x = 3，那么赋值语句x = 'abcedfg'是无法正常执行的。[ ]
48. 语句pass仅起到占位符的作用，并不会做任何操作。[ ]
49. Python 2.x和Python 3.x中input()函数的返回值都是字符串。[ ]
50. 在Python 3.x中，使用内置函数input()接收用户输入时，不论用户输入的什么格式，一律按字符串进行返回。[ ]
51. 只有Python扩展库才需要导入以后才能使用其中的对象，Python标准库不需要导入即可使用其中的所有对象和方法。[ ]
52. 尽管可以使用import语句一次导入任意多个标准库或扩展库，但是仍建议每次只导入一个标准库或扩展库。[ ]
53. 执行语句 from math import sin 之后，可以直接使用 sin() 函数，例如 sin(3)。[ ]
54. 如果只需要math模块中的sin()函数，建议使用from math import sin来导入，而不要使用import math导入整个模块。[ ]
55. 加法运算符可以用来连接字符串并生成新字符串。[ ]
56. 在UTF-8编码中一个汉字需要占用3个字节。[ ]
57. 在GBK和CP936编码中一个汉字需要2个字节。[ ]
58. 相同内容的字符串使用不同的编码格式进行编码得到的结果并不完全相同。[ ]
59. 在Python中，任意长的字符串都遵守驻留机制。[ ]
60. Python字符串方法replace()对字符串进行原地修改。[ ]
61. 如果需要连接大量字符串成为一个字符串，那么使用字符串对象的join()方法比运算符+具有更高的效率。[ ]
62. 已知x为非空字符串，那么表达式 ''.join(x.split()) == x 的值一定为True。[ ]
63. 已知x为非空字符串，那么表达式 ','.join(x.split(',')) == x 的值一定为True。[ ]
64. 已知x和y是两个字符串，那么表达式sum((1 for i,j in zip(x,y) if i==j))可以用来计算两个字符串中对应位置字符相等的个数。[ ]
65. Python 3.x中字符串对象的encode()方法默认使用utf8作为编码方式。[ ]
66. 已知x = 'hellow world.'.encode()，那么表达式x.decode('gbk')的值为'hellow world.'。[ ]
67. 已知x = 'Python是一种非常好的编程语言'.encode()，那么表达式x.decode('gbk')的值为'Python是一种非常好的编程语言'。[ ]
68. 对字符串信息进行编码以后，必须使用同样的或者兼容的编码格式进行解码才能还原本来的信息。[ ]
69. Python运算符%不仅可以用来求余数，还可以用来格式化字符串。[ ]
70. 带有else子句的循环如果因为执行了break语句而退出的话，则会执行else子句中的代码。[ ]
71. 对于带有else子句的循环语句，如果是因为循环条件表达式不成立而自然结束循环，则执行else子句中的代码。[ ]
72. 如果仅仅是用于控制循环次数，那么使用for i in range(20)和for i in range(20, 40)的作用是等价的。[ ]
73. 在循环中continue语句的作用是跳出当前循环。[ ]
74. 在编写多层循环时，为了提高运行效率，应尽量减少内循环中不必要的计算。[ ]
75. 假设已导入random标准库，那么表达式 max([random.randint(1, 10) for i in range(10)]) 的值一定是10。[ ]
76. Python标准库random的方法randint(m,n)用来生成一个[m,n]区间上的随机整数。[ ]
77. 假设random模块已导入，那么表达式 random.sample(range(10), 20) 的作用是生成20个不重复的整数。[ ]
78. 假设random模块已导入，那么表达式 random.sample(range(10), 7) 的作用是生成7个不重复的整数。[ ]
79. 使用random模块的函数randint(1, 100)获取随机数时，有可能会得到100。[ ]
80. 程序中异常处理结构在大多数情况下是没必要的。[ ]
81. 在try...except...else结构中，如果try块的语句引发了异常则会执行else块中的代码。[ ]
82. 异常处理结构中的finally块中代码仍然有可能出错从而再次引发异常。[ ]
83. 带有else子句的异常处理结构，如果不发生异常则执行else子句中的代码。[ ]
84. 异常处理结构也不是万能的，处理异常的代码也有引发异常的可能。[ ]
85. 在异常处理结构中，不论是否发生异常，finally子句中的代码总是会执行的。[ ]
86. 由于异常处理结构try...except...finally...中finally里的语句块总是被执行的，所以把关闭文件的代码放到finally块里肯定是万无一失，一定能保证文件被正确关闭并且不会引发任何异常。[ ]
87. 调用函数时，在实参前面加一个型号*表示序列解包。[ ]
88. 函数是代码复用的一种方式。[ ]
89. 定义Python函数时必须指定函数返回值类型。[ ]
90. 定义Python函数时，如果函数中没有return语句，则默认返回空值None。[ ]
91. 如果在函数中有语句 return 3，那么该函数一定会返回整数3。[ ]
92. 函数中必须包含return语句。[ ]
93. 函数中的return语句一定能够得到执行。[ ]
94. 全局变量会增加不同函数之间的隐式耦合度，从而降低代码可读性，因此应尽量避免过多使用全局变量。[ ]
95. 函数内部定义的局部变量当函数调用结束后被自动删除。[ ]
96. 在函数内部，既可以使用global来声明使用外部全局变量，也可以使用global直接定义全局变量。[ ]
97. 在函数内部没有办法定义全局变量。[ ]
98. 在函数内部直接修改形参的值并不影响外部实参的值。[ ]
99. 在函数内部没有任何方法可以影响实参的值。[ ]
100. 在同一个作用域内，局部变量会隐藏同名的全局变量。[ ]
101. 在Python中定义函数时不需要声明函数参数的类型。[ ]
102. 在Python中定义函数时不需要声明函数的返回值类型。[ ]
103. 在函数中没有任何办法可以通过形参来影响实参的值。[ ]
104. 在定义函数时，某个参数名字前面带有一个*符号表示可变长度参数，可以接收任意多个普通实参并存放于一个元组之中。[ ]
105. 在定义函数时，某个参数名字前面带有两个*符号表示可变长度参数，可以接收任意多个关键参数并将其存放于一个字典之中。[ ]
106. 定义函数时，带有默认值的参数必须出现在参数列表的最右端，任何一个带有默认值的参数右边不允许出现没有默认值的参数。[ ]
107. 包含yield语句的函数一般成为生成器函数，可以用来创建生成器对象。[ ]
108. 在函数中yield语句的作用和return完全一样。[ ]
109. 函数和对象方法是一样的，内部实现和外部调用都没有任何区别。[ ]
110. lambda表达式中可以使用任意复杂的表达式，但是必须只编写一个表达式。[ ]
111. g = lambda x: 3不是一个合法的赋值表达式。[ ]
112. 无法使用lambda表达式定义有名字的函数。[ ]
113. 在Python 3.x中语句 print(*[1,2,3]) 不能正确执行。[ ]
114. 定义函数时，即使该函数不需要接收任何参数，也必须保留一对空的圆括号来表示这是一个函数。[ ]
115. 编写函数时，一般建议先对参数进行合法性检查，然后再编写正常的功能代码。[ ]
116. 一个函数如果带有默认值参数，那么必须所有参数都设置默认值。[ ]
117. 调用带有默认值参数的函数时，不能为默认值参数传递任何值，必须使用函数定义时设置的默认值。[ ]
118. 形参可以看做是函数内部的局部变量，函数运行结束之后形参就不可访问了。[ ]
119. 在调用函数时，可以通过关键参数的形式进行传值，从而避免必须记住函数形参顺序的麻烦。[ ]
120. 在调用函数时，必须牢记函数形参顺序才能正确传值。[ ]
121. 调用函数时传递的实参个数必须与函数形参个数相等才行。[ ]
122. 在编写函数时，建议首先对形参进行类型检查和数值范围检查之后再编写功能代码，或者使用异常处理结构，尽量避免代码抛出异常而导致程序崩溃。[ ]
123. 不同作用域中的同名变量之间互相不影响，也就是说，在不同的作用域内可以定义同名的变量。[ ]
124. 在函数内部没有任何声明的情况下直接为某个变量赋值，这个变量一定是函数内部的局部变量。[ ]
125. 在Python 3.x中reduce()是内置函数。[ ]
126. 内置函数len()返回指定序列的元素个数，适用于列表、元组、字符串、字典、集合以及range、zip等迭代对象。[ ]
127. 在Python 3.5中运算符+不仅可以实现数值的相加、字符串连接，还可以实现列表、元组的合并和集合的并集运算。[ ]
128. Python列表、元组、字符串都属于有序序列。[ ]
129. Python字典和集合属于无序序列。[ ]
130. 只能对列表进行切片操作，不能对元组和字符串进行切片操作。[ ]
131. 只能通过切片访问元组中的元素，不能使用切片修改元组中的元素。[ ]
132. 字符串属于Python有序序列，和列表、元组一样都支持双向索引。[ ]
133. Python字典和集合支持双向索引。[ ]
134. 列表可以作为字典的“键”。[ ]
135. 已知x为非空列表，那么表达式 sorted(x, reverse=True) == list(reversed(x)) 的值一定是True。[ ]
136. 已知x为非空列表，那么x.sort(reverse=True)和x.reverse()的作用是等价的。[ ]
137. Python列表中所有元素必须为相同类型的数据。[ ]
138. 列表对象的append()方法属于原地操作，用于在列表尾部追加一个元素。[ ]
139. 对于列表而言，在尾部追加元素比在中间位置插入元素速度更快一些，尤其是对于包含大量元素的列表。[ ]
140. 假设有非空列表x，那么x.append(3)、x = x+[3]与x.insert(0,3)在执行时间上基本没有太大区别。[ ]
141. 使用Python列表的方法insert()为列表插入元素时会改变列表中插入位置之后元素的索引。[ ]
142. 假设x为列表对象，那么x.pop()和x.pop(-1)的作用是一样的。[ ]
143. 使用del命令或者列表对象的remove()方法删除列表中元素时会影响列表中部分元素的索引。[ ]
144. 已知列表 x = [1, 2, 3]，那么执行语句 x = 3 之后，变量x的地址不变。[ ]
145. 使用列表对象的remove()方法可以删除列表中首次出现的指定元素，如果列表中不存在要删除的指定元素则抛出异常。[ ]
146. 假设x是含有5个元素的列表，那么切片操作x[10:]是无法执行的，会抛出异常。[ ]
147. 只能通过切片访问列表中的元素，不能使用切片修改列表中的元素。[ ]
148. 删除列表中重复元素最简单的方法是将其转换为集合后再重新转换为列表。[ ]
149. 已知列表x中包含超过5个以上的元素，那么语句 x = x[:5]+x[5:] 的作用是将列表x中的元素循环左移5位。[ ]
150. 对于生成器对象x = (3 for i in range(5))，连续两次执行list(x)的结果是一样的。[ ]
151. 对于大量列表的连接，extend()方法比运算符+具有更高的效率。[ ]
152. 列表对象的extend()方法属于原地操作，调用前后列表对象的地址不变。[ ]
153. 对于数字n，如果表达式 0 not in [n%d for d in range(2, n)] 的值为True则说明n是素数。[ ]
154. 已知seq为长度大于10的列表，并且已导入random模块，那么[random.choice(seq) for i in range(10)]和random.sample(seq,10)等价。[ ]
155.  假设os模块已导入，那么列表推导式 [filename for filename in os.listdir('C:\\Windows') if filename.endswith('.exe')] 的作用是列出C:\Windows文件夹中所有扩展名为.exe的文件。[ ]
156. 表达式 list('[1, 2, 3]') 的值是[1, 2, 3]。[ ]
157. 同一个列表对象中的元素类型可以各不相同。[ ]
158. 同一个列表对象中所有元素必须为相同类型。[ ]
159. 已知x为非空列表，那么执行语句x[0] = 3之后，列表对象x的内存地址不变。[ ]
160. 集合可以作为列表的元素。[ ]
161. 列表对象的pop()方法默认删除并返回最后一个元素，如果列表已空则抛出异常。[ ]
162. 已知列表x = [1, 2, 3, 4]，那么表达式x.find(5)的值应为-1。[ ]
163. 列表对象的排序方法sort()只能按元素从小到大排列，不支持别的排序方式。[ ]
164. 已知x和y是两个等长的整数列表，那么表达式sum((i*j for i, j in zip(x, y)))的作用是计算这两个列表所表示的向量的内积。[ ]
165. 已知x和y是两个等长的整数列表，那么表达式[i+j for i,j in zip(x,y)]的作用时计算这两个列表所表示的向量的和。[ ]
166. 已知x = list(range(20))，那么语句del x[::2]可以正常执行。[ ]
167. 已知x = list(range(20))，那么语句x[::2] = []可以正常执行。[ ]
168. 已知x = list(range(20))，那么语句print(x[100:200])无法正常执行。[ ]
169. 已知x是个列表对象，那么执行语句y = x之后，对y所做的任何操作都会同样作用到x上。[ ]
170. 已知x是个列表对象，那么执行语句y = x[:]之后，对y所做的任何操作都会同样作用到x上。[ ]
171. 已知x是一个列表，那么x = x[3:] + x[:3]可以实现把列表x中的所有元素循环左移3位。[ ]
172. 元组可以作为字典的“键”。[ ]
173. 生成器推导式比列表推导式具有更高的效率，推荐使用。[ ]
174. 元组是不可变的，不支持列表对象的insert()、remove()等方法，也不支持del命令删除其中的元素，但可以使用del命令删除整个元组对象。[ ]
175. 元组的访问速度比列表要快一些，如果定义了一系列常量值，并且主要用途仅仅是对其进行遍历而不需要进行任何修改，建议使用元组而不使用列表。[ ]
176. 创建只包含一个元素的元组时，必须在元素后面加一个逗号，例如(3,)。[ ]
177. 集合可以作为元组的元素。[ ]
178. Python元组支持双向索引。[ ]
179. 已知x = (1, 2, 3, 4)，那么执行x[0] = 5之后，x的值为(5, 2, 3, 4)。[ ]
180. 表达式(i**2 for i in range(100))的结果是个元组。[ ]
181. 在Python中元组的值是不可变的，因此，已知x = ([1], [2])，那么语句x[0].append(3)是无法正常执行的。[ ]
182. Python支持使用字典的“键”作为下标来访问字典中的值。[ ]
183. 字典的“键”必须是不可变的。[ ]
184. Python字典中的“键”不允许重复。[ ]
185. Python字典中的“值”不允许重复。[ ]
186. Python字典中的“键”可以是列表。[ ]
187. Python字典中的“键”可以是元组。[ ]
188. 当以指定“键”为下标给字典对象赋值时，若该“键”存在则表示修改该“键”对应的“值”，若不存在则表示为字典对象添加一个新的“键-值对”。[ ]
189. 集合可以作为字典的键。[ ]
190. 集合可以作为字典的值。[ ]
191. Python字典支持双向索引。[ ]
192. Python内置的字典dict中元素是按添加的顺序依次进行存储的。[ ]
193. 已知x = {1:1, 2:2}，那么语句x[3] =3无法正常执行。[ ]
194. Python内置字典是无序的，如果需要一个可以记住元素插入顺序的字典，可以使用collections.OrderedDict。[ ]
195. Python集合中的元素不允许重复。[ ]
196. Python集合可以包含相同的元素。[ ]
197. Python集合中的元素可以是元组。[ ]
198. Python集合中的元素可以是列表。[ ]
199. 已知A和B是两个集合，并且表达式A<B的值为False，那么表达式A>B的值一定为True。[ ]
200. 无法删除集合中指定位置的元素，只能删除特定值的元素。[ ]
201. Python集合不支持使用下标访问其中的元素。[ ]
202. 运算符“-”可以用于集合的差集运算。[ ]
203. 列表可以作为集合的元素。[ ]
204. 元组可以作为集合的元素。[ ]
205. 字典可以作为集合的元素。[ ]
206. 可以使用del删除集合中的部分元素。[ ]
207. 表达式 {1, 2} * 2 的值为 {1, 2, 1, 2}。[ ]
208. Python集合支持双向索引。[ ]
209. 成员测试运算符in作用于集合时比作用于列表快得多。[ ]
210. Python内置的集合set中元素顺序是按元素的哈希值进行存储的，并不是按先后顺序。[ ]
211. 栈和队列的都具有先入后出的特点。[ ]
212. 扩展库os中的方法remove()可以删除带有只读属性的文件。[ ]
213. 使用内置函数open()且以“w”模式打开的文件，文件指针默认指向文件尾。[ ]
214. 使用内置函数open()打开文件时，只要文件路径正确就总是可以正确打开的。[ ]
215. 使用print()函数无法将信息写入文件。[ ]
216. 对文件进行读写操作之后必须显式关闭文件以确保所有内容都得到保存。[ ]
217. Python标准库os中的方法startfile()可以启动任何已关联应用程序的文件，并自动调用关联的程序。[ ]
218. 二进制文件不能使用记事本程序打开。[ ]
219. 使用普通文本编辑器软件也可以正常查看二进制文件的内容。[ ]
220. 二进制文件也可以使用记事本或其他文本编辑器打开，但是一般来说无法正常查看其中的内容。[ ]
221. 文件对象是可以迭代的。[ ]
222. 文件对象的tell()方法用来返回文件指针的当前位置。[ ]
223. 以写模式打开的文件无法进读操作。[ ]
224. 以读模式打开文件时，文件指针指向文件开始处。[ ]
225. 以追加模式打开文件时，文件指针指向文件尾。[ ]
226. 二进制文件也可以使用记事本程序打开，只是无法正确阅读和理解其中的内容。[ ]
227. 文本文件是可以迭代的，可以使用for line in fp类似的语句遍历文件对象fp中的每一行。[ ]
228. Python的主程序文件python.exe属于二进制文件。[ ]
229. 使用记事本程序也可以打开二进制文件，只不过无法正确识别其中的内容。[ ]
230. 使用pickle进行序列化得到的二进制文件使用struct也可以正确地进行反序列化。[ ]
231. 已知当前文件夹中有一个文件readme.txt具有只读属性，假设标准库os已正确导入，那么可以通过语句os.chmod('readme.txt', 0o777)来删除该文件的只读属性。[ ]
232. Python标准库os的函数remove()不能删除具有只读属性的文件。[ ]
233. pip命令也支持扩展名为.whl的文件直接安装Python扩展库。[ ]
234. 一般来说，Python扩展库没有通用于所有版本Python的，安装时应选择与已安装Python的版本对应的扩展库。[ ]
235. 安装Python扩展库时只能使用pip工具在线安装，如果安装不成功就没有别的办法了。[ ]
236. Python中一切内容都可以称为对象。[ ]
237. 任何包含__call__()方法的类的对象都是可调用的。[ ]
238. 在Python中函数和类都属于可调用对象。[ ]
239. 正则表达式模块re的match()方法是从字符串的开始匹配特定模式，而search()方法是在整个字符串中寻找模式，这两个方法如果匹配成功则返回match对象，匹配失败则返回空值None。[ ]
240. 正则表达式对象的match()方法可以在字符串的指定位置开始进行指定模式的匹配。[ ]
241. 使用正则表达式对字符串进行分割时，可以指定多个分隔符，而字符串对象的split()方法无法做到这一点。[ ]
242. 正则表达式元字符“^”一般用来表示从字符串开始处进行匹配，用在一对方括号中的时候则表示反向匹配，不匹配方括号中的字符。[ ]
243. 正则表达式元字符“\s”用来匹配任意空白字符。[ ]
244. 正则表达式 元字符“\d”用来匹配任意数字字符。[ ]
245. 假设re模块已成功导入，并且有 pattern = re.compile('^' + '\.'.join([r'\d{1,3}' for i in range(4)])+'$')，那么表达式 pattern.match('192.168.1.103') 的值为None。[ ]
246. 正则表达式'^http'只能匹配所有以'http'开头的字符串。[ ]
247. 正则表达式'^\d{18}|\d{15}$'只能检查给定字符串是否为18位或15位数字字符，并不能保证一定是合法的身份证号。[ ]
248. 正则表达式'[^abc]'可以一个匹配任意除'a'、'b'、'c'之外的字符。[ ]
249. 正则表达式'python|perl'或'p(ython|erl)'都可以匹配'python'或'perl'。[ ]
250. 在面向对象程序设计中，函数和方法是完全一样的，都必须为所有参数进行传值。[ ]
251. 定义类时所有实例方法的第一个参数用来表示对象本身，在类的外部通过对象名来调用实例方法时不需要为该参数传值。[ ]
242. Python中没有严格意义上的私有成员。[ ]
253. 对于Python类中的私有成员，可以通过“对象名._类名__私有成员名”的方式来访问。[ ]
254. 如果定义类时没有编写析构函数，Python将提供一个默认的析构函数进行必要的资源清理工作。[ ]
255. 定义类时如果实现了__contains__()方法，该类对象即可支持成员测试运算in。[ ]
256. 定义类时如果实现了__len__()方法，该类对象即可支持内置函数len()。[ ]
257. 定义类时实现了__eq__()方法，该类对象即可支持运算符==。[ ]
258. 定义类时实现了__pow__()方法，该类对象即可支持运算符**。[ ]
259. 在Python中定义类时，如果某个成员名称前有2个下划线则表示是私有成员。[ ]
260. 在类定义的外部没有任何办法可以访问对象的私有成员。[ ]
261. Python类的构造函数是__init__()。[ ]
262. 定义类时，在一个方法前面使用@classmethod进行修饰，则该方法属于类方法。[ ]
263. 定义类时，在一个方法前面使用@staticmethod进行休息，则该方法属于静态方法。[ ]
264. 在Python中可以为自定义类的对象动态增加新成员。[ ]
265. 只可以动态为对象增加数据成员，而不能为对象动态增加成员方法。[ ]
266. 如果在设计一个类时实现类__len__()方法，那么该类的对象会自动支持Python内置函数len()。[ ]
267. 在Python中定义类时实例方法的第一个参数名称必须是self。[ ]
268. 在Python中定义类时实例方法的第一个参数名称不管是什么，都表示对象自身。[ ]
269. 通过对象不能调用类方法和静态方法。[ ]
270. 属性可以像数据成员一样进行访问，但赋值时具有方法的优点，可以对新值进行检查。[ ]
271. 在Python中定义类时，运算符重载是通过重写特殊方法实现的。例如，在类中实现了__mul__()方法即可支持该类对象的**运算符。[ ]
272. 在派生类中可以通过“基类名.方法名()”的方式来调用基类中的方法。[ ]
273. Python支持多继承，如果父类中有相同的方法名，而在子类中调用时没有指定父类名，则Python解释器将从左向右按顺序进行搜索。[ ]
274. Python类不支持多继承。[ ]
275. 在设计派生类时，基类的私有成员默认是不会继承的。[ ]
276. Python标准库os中的方法startfile()可以用来打开外部程序或文件，系统会自动关联相应的程序来打开或执行指定的文件。[ ]
277. Python标准库os中的方法isfile()可以用来测试给定的路径是否为文件。[ ]
278. Python标准库os中的方法exists()可以用来测试给定路径的文件是否存在。[ ]
279. Python标准库os中的方法isdir()可以用来测试给定的路径是否为文件夹。[ ]
280. Python标准库os中的方法listdir()返回包含指定路径中所有文件和文件夹名称的列表。[ ]
281. Python扩展库xlwt支持对Excel 2003或更低版本的Excel文件进行写操作。[ ]
282. Python扩展库xlrd支持对Excel 2003或更低版本的Excel文件进行读操作。[ ]
283. 标准库os的rename()方法可以实现文件移动操作。[ ]
284. 标准库os的listdir()方法默认只能列出指定文件夹中当前层级的文件和文件夹列表，而不能列出其子文件夹中的文件。[ ]
285. 假设已成功导入os和sys标准库，那么表达式 os.path.dirname(sys.executable) 的值为Python安装目录。[ ]
286. 在GUI设计中，复选框往往用来实现非互斥多选的功能，多个复选框之间的选择互不影响。[ ]
287. 在GUI设计中，单选按钮用来实现用户在多个选项中的互斥选择，在同一组内多个选项中只能选择一个，当选择发生变化之后，之前选中的选项自动失效。[ ]
288. Python代码可以内嵌在asp文件中。[ ]
289. 无法配置IIS来支持Python程序的运行。[ ]
290. 使用TCP协议进行通信时，必须首先建立连接，然后进行数据传输，最后再关闭连接。[ ]
291. TCP是可以提供良好服务质量的传输层协议，所以在任何场合都应该优先考虑使用。[ ]
292. 继承自threading.Thread类的派生类中不能有普通的成员方法。[ ]
293. 在编写应用程序时，应合理控制线程数量，线程并不是越多越好。[ ]
294. 在多线程编程时，当某子线程的daemon属性为False时，主线程结束时会检测该子线程是否结束，如果该子线程尚未运行结束，则主线程会等待它完成后再退出。[ ]
295. 在4核CPU平台上使用多线程编程技术可以很轻易地获得400%的处理速度提升。[ ]
296. 多线程编程技术主要目的是为了提高计算机硬件的利用率，没有别的作用了。[ ]
297. Python标准库threading中的Lock、RLock、Condition、Event、Semaphore对象都可以用来实现线程同步。[ ]
298. Python只能使用内置数据库SQLite，无法访问MS SQLServer、ACCESS或Oracle、MySQL等数据库。[ ]
299. 使用OpenGL画图时，画点是最基本的操作，具体生成的图形由glBegin()函数指定的mode来决定。例如，mode值为GL_TRIANGLES时表示将要绘制三角形。[ ]
300. OpenGL采用的“状态机”工作方式，一旦设置了某种状态以后，除非显式修改该状态，否则该状态将一直保持。[ ]
301. 字节串b'hello world'和b'hello world.'的MD5值相差很小。[ ]
